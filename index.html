<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TIBCO .bwp Analyzer (Client‑side)</title>
  <meta name="description" content="Upload a TIBCO BusinessWorks .bwp file to visualize workflows, list activities/interfaces, and export human‑readable documentation." />
  <style>
    :root { --bg: #0b1020; --panel:#121933; --ink:#e7ecff; --muted:#9fb0ff; --accent:#7aa2ff; --good:#40d19a; --warn:#ffd166; --bad:#ff6b6b; }
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--ink);font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";}
    .wrap{max-width:1200px;margin:0 auto;padding:24px;}
    h1{font-weight:800;letter-spacing:.2px;margin:.2em 0 .2em;font-size:clamp(24px,3vw,34px);}    
    .sub{color:var(--muted);margin-top:0}
    .panel{background:linear-gradient(180deg, #101736 0%, #0f1530 100%);border:1px solid #1f2a55;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .row{display:flex;gap:16px;flex-wrap:wrap}
    .col{flex:1 1 380px}
    .hdr{display:flex;align-items:center;justify-content:space-between;padding:14px 16px;border-bottom:1px solid #1f2a55}
    .hdr h2{font-size:16px;margin:0;color:#cfe0ff;text-transform:uppercase;letter-spacing:.12em}
    .body{padding:16px}
    .muted{color:#8aa0ff}
    .fine{font-size:12px;color:#90a3ff}
    .chip{display:inline-flex;gap:6px;align-items:center;background:#1a2250;border:1px solid #243073;padding:6px 10px;border-radius:999px;font-size:12px;color:#cfe0ff}
    .btns{display:flex;gap:10px;flex-wrap:wrap}
    button,.btn{background:#26357a;color:#fff;border:1px solid #3850c3;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
    button:hover,.btn:hover{filter:brightness(1.1)}
    .primary{background:linear-gradient(180deg,#3b6cff,#2c57e0);border-color:#3b6cff}
    .danger{background:#722b2b;border-color:#b44444}
    input[type="file"]{display:none}
    label.file{display:inline-flex;gap:8px;align-items:center;background:#1a2250;border:1px dashed #3850c3;color:#cfe0ff;padding:14px 16px;border-radius:12px;cursor:pointer}
    #drop{border:2px dashed #3850c3;border-radius:14px;padding:24px;text-align:center;color:#cfe0ff;background:rgba(56,80,195,.08)}
    #drop.drag{background:rgba(122,162,255,.15);border-color:#7aa2ff}
    code.inline{background:#0c1330;border:1px solid #243073;border-radius:6px;padding:2px 6px}
    pre{background:#0c1330;border:1px solid #243073;border-radius:10px;padding:12px;overflow:auto;color:#eaf1ff}
    details{background:#0e1433;border:1px solid #243073;border-radius:12px;padding:10px 12px}
    details>summary{cursor:pointer;color:#cfe0ff}
    table{width:100%;border-collapse:collapse;font-size:14px}
    th,td{padding:8px 10px;border-bottom:1px solid #1f2a55;text-align:left}
    th{color:#cfe0ff}
    .tag{font-size:11px;background:#253164;color:#cfe0ff;padding:2px 6px;border-radius:6px;border:1px solid #3a4ba0}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px}
    .stat{background:#0e1538;border:1px solid #28367a;border-radius:12px;padding:12px}
    .stat h3{margin:0 0 6px 0;font-size:13px;color:#9fb0ff;text-transform:uppercase;letter-spacing:.08em}
    .stat .v{font-weight:800;font-size:22px}
    .hidden{display:none}
    .mermaid{background:#0c1330;border:1px solid #27367a;border-radius:10px;padding:12px}
    /* Ensure rendered SVGs fill their containers and stay responsive */
    .mermaid svg{width:100%;height:auto;max-width:none;}
    /* Give the diagram container a minimum height and allow scrolling if necessary */
    #mermaid{min-height:520px;overflow:auto;border:1px solid #27367a;border-radius:12px;padding:8px}
    footer{margin:36px 0;color:#8aa0ff}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  </style>
  <!-- Mermaid -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <!-- JSZip + FileSaver for zip handling and downloads -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <!-- dom-to-image and jsPDF for exporting diagrams -->
  <script src="https://cdn.jsdelivr.net/npm/dom-to-image@2.6.0/dist/dom-to-image.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>TIBCO <span style="color:var(--accent)">.bwp</span> Analyzer</h1>
    <p class="sub">Upload a TIBCO BusinessWorks <code class="inline">.bwp</code> file. This app parses it client‑side to produce a human‑readable summary, Mermaid diagrams (flowchart/sequence), and exportable documentation (Markdown/HTML). All processing stays in your browser.</p>

    <div class="row">
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>1) Upload .bwp</h2><span class="fine">Drag & drop or choose a file</span></div>
          <div class="body">
            <div id="drop">
              <p>Drop your <b>.bwp</b> here</p>
              <p class="fine">or</p>
              <label class="file"><input id="file" type="file" accept=".bwp,.xml,.zip"/>Choose file</label>
            </div>
            <div id="fileInfo" class="fine" style="margin-top:10px"></div>

            <!-- Additional controls: add file to current analysis and clear analysis -->
            <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
              <label class="file"><input id="fileAdd" type="file" accept=".bwp,.xml,.zip"/>Add to analysis</label>
              <button id="btnClearAnalysis" class="danger" style="padding:10px 14px">Clear analysis</button>
            </div>
          </div>
        </div>
      </div>
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>2) Quick Stats</h2><span class="fine">Parsed elements</span></div>
          <div class="body">
            <div class="grid">
              <div class="stat"><h3>Processes</h3><div class="v" id="sProcesses">0</div></div>
              <div class="stat"><h3>Activities</h3><div class="v" id="sActivities">0</div></div>
              <div class="stat"><h3>Transitions</h3><div class="v" id="sTransitions">0</div></div>
              <div class="stat"><h3>Bindings/Interfaces</h3><div class="v" id="sInterfaces">0</div></div>
              <div class="stat"><h3>Variables</h3><div class="v" id="sVars">0</div></div>
              <div class="stat"><h3>Fault/Handlers</h3><div class="v" id="sFaults">0</div></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:16px">
      <div class="hdr"><h2>3) Workflow Diagram (Mermaid)</h2>
        <div class="btns">
          <label class="fine" style="margin-right:6px">Dir:
            <select id="optDir" class="btn" style="padding:6px 8px">
              <option value="TD">TD</option>
              <option value="LR">LR</option>
            </select>
          </label>
          <label class="fine" style="margin-right:6px">Level:
            <select id="optLevel" class="btn" style="padding:6px 8px">
              <option value="0">Process only</option>
              <option value="1">Containers</option>
              <option value="2" selected>Containers + 1st‑level activities</option>
              <option value="3">All activities</option>
            </select>
          </label>
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optSwim" type="checkbox"> Swimlanes</label>
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optLinearize" type="checkbox"> Linearize (ignore links)</label>
          <!-- Repeating nodes control: applies to any frequently appearing containers such as sequence or children -->
          <label class="fine" style="margin-right:6px">Repeating nodes:
            <select id="optSeqDisplay" class="btn" style="padding:6px 8px">
              <option value="show">Show</option>
              <option value="annotate" selected>Annotate (#items)</option>
              <option value="hide">Hide</option>
            </select>
          </label>
          <!-- New toggles for enhanced context -->
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optService" type="checkbox" checked> Service info</label>
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optVars" type="checkbox"> Variables</label>
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optConds" type="checkbox" checked> Edge labels</label>

          <!-- Additional controls for rich diagramming -->
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optColors" type="checkbox"> Type colors</label>
          <label class="fine" style="display:inline-flex;align-items:center;gap:6px"><input id="optIcons" type="checkbox"> Icons</label>
          <input id="searchFilter" class="btn" style="padding:6px 8px;width:140px" placeholder="Search…" title="Filter nodes by name, type, or partner link"/>
          <button id="btnDataFlow">Data Flow</button>
          <button id="btnExportPNG">Export PNG</button>
          <button id="btnExportPDF">Export PDF</button>
          <button id="btnFlow" class="primary">Build Flowchart</button>
          <button id="btnSeq">Build Sequence</button>
          <!-- Zoom controls for Mermaid diagram -->
          <button id="zoomIn">Zoom +</button>
          <button id="zoomOut">Zoom −</button>
          <button id="zoomReset">Fit</button>
          <!-- Expand/collapse all details in the diagram panel -->
          <button id="btnToggleDiagramDetails" title="Expand or collapse all details">Expand All</button>
        </div>
      </div>
      <div class="body">
        <div id="mermaid" class="mermaid">graph TD; A[Upload .bwp]-->B{Parse}; B-->C[Summarize]; C-->D[Export Docs];</div>
        <details id="mermaidSource" style="margin-top:10px">
          <summary>Show Mermaid source</summary>
          <pre id="mermaidSrc" class="mono"></pre>
        </details>

        <!-- Appearance customization: color pickers and icon selectors for each category -->
        <details id="appearanceConfig" style="margin-top:12px">
          <summary class="fine">Customize icons &amp; colors</summary>
          <div style="margin-top:8px">
            <p class="fine">Select a color and icon for each activity category. Icons accept emoji or short text labels. These settings apply when <i>Type colors</i> and <i>Icons</i> options are enabled.</p>
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-top:8px">
              <div>
                <label class="fine">Service color</label><br/>
                <input type="color" id="colorService" value="#3b6cff" style="width:100%"/>
                <input type="text" id="iconService" value="🔧" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Transformation color</label><br/>
                <input type="color" id="colorTransformation" value="#40d19a" style="width:100%"/>
                <input type="text" id="iconTransformation" value="🔁" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Decision color</label><br/>
                <input type="color" id="colorDecision" value="#ffd166" style="width:100%"/>
                <input type="text" id="iconDecision" value="❓" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Error color</label><br/>
                <input type="color" id="colorError" value="#ff6b6b" style="width:100%"/>
                <input type="text" id="iconError" value="⚠️" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Loop color</label><br/>
                <input type="color" id="colorLoop" value="#a084ca" style="width:100%"/>
                <input type="text" id="iconLoop" value="🔄" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Timer color</label><br/>
                <input type="color" id="colorTimer" value="#9e4770" style="width:100%"/>
                <input type="text" id="iconTimer" value="⏲" style="width:100%;margin-top:4px"/>
              </div>
              <div>
                <label class="fine">Other color</label><br/>
                <input type="color" id="colorOther" value="#5b6988" style="width:100%"/>
                <input type="text" id="iconOther" value="⚙️" style="width:100%;margin-top:4px"/>
              </div>
            </div>
          </div>
        </details>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>4) Process Summary</h2>
            <div class="btns">
              <button id="btnExportMD">Export Markdown</button>
              <button id="btnExportHTML">Export HTML</button>
            </div>
          </div>
          <div class="body" id="summary"></div>
        </div>
      </div>
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>Activities & Transitions</h2>
            <div class="btns">
              <span class="fine" style="margin-right:8px">Grouped by type with links</span>
              <!-- Expand/Collapse all details toggle -->
              <button id="btnToggleDetails" class="btn" title="Expand or collapse all sections">Collapse All</button>
            </div>
          </div>
          <div class="body">
            <div id="activities"></div>
            <div id="details" style="margin-top:12px"></div>
          </div>
        </div>
      </div>
      <!-- Narrative panel: describes the workflow in natural language using extracted context -->
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>Narrative</h2><span class="fine">Human‑readable description of the workflow</span></div>
          <div class="body">
            <div id="narrative" class="fine"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="panel" style="margin-top:16px">
      <div class="hdr"><h2>BPEL Outline</h2><span class="fine">sequence / flow / scope with nested activities</span></div>
      <div class="body" id="outline"></div>
    </div>

    <!-- Metrics and Best Practices panels -->
    <div class="row" style="margin-top:16px">
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>Complexity Metrics</h2><span class="fine">counts, parallelism & depth</span></div>
          <div class="body" id="metrics" class="fine"></div>
        </div>
      </div>
      <div class="col">
        <div class="panel">
          <div class="hdr"><h2>Best Practices</h2><span class="fine">warnings & suggestions</span></div>
          <div class="body" id="bestPractices" class="fine"></div>
        </div>
      </div>
    </div>

    <footer>
      <div class="fine">Notes:
        <ul>
          <li>This viewer is schema‑tolerant: it tries to parse common BusinessWorks process structures from <code>.bwp</code> (XML) or zipped project bundles and gracefully lists unknown tags/attributes.</li>
          <li>Mermaid diagrams are heuristically generated from activities and transitions. Review and tweak the exported Mermaid code as needed.</li>
          <li>Everything runs client‑side; no data leaves your machine.</li>
        </ul>
      </div>
    </footer>
  </div>

<script>
  // --- Mermaid init ---
  // Wrap Mermaid initialization in try/catch so that a failure to load the library
  // does not break the rest of the application. We disable automatic startOnLoad
  // because we manually invoke mermaid.run() when diagrams are rendered.
  try {
    mermaid.initialize({ startOnLoad: false, securityLevel: 'loose', theme: 'dark' });
  } catch (e) {
    console.warn('Mermaid initialization failed', e);
  }

  // --- State ---
  let state = {
    xmlDoc: null,
    model: null, // normalized in-memory representation
    fileName: null,
  };

  // Analysis state: support multiple models when adding files
  let analysisModels = [];
  // Map from rendered nodeId to underlying activity/container for detail lookup
  let nodeMap = {};
  // Set of currently selected nodeIds for interactive detail view
  let selectedNodes = new Set();

  const el = (id)=>document.getElementById(id);

  // Global error handler: display script errors on the page for easier debugging
  window.addEventListener('error', (evt) => {
    try {
      const container = document.getElementById('fileInfo') || document.body;
      const msg = document.createElement('p');
      msg.style.color = 'var(--bad)';
      msg.style.fontSize = '12px';
      msg.textContent = 'Error: '+evt.message+' ('+(evt.filename||'')+':'+evt.lineno+':'+evt.colno+')';
      container.appendChild(msg);
    } catch (err) {
      // ignore
    }
  });

  // --- Drag & Drop ---
  const drop = el('drop');
  const fileInput = el('file');

  ['dragenter','dragover'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.add('drag');}));
  ;['dragleave','drop'].forEach(evt=>drop.addEventListener(evt,e=>{e.preventDefault();drop.classList.remove('drag');}));
  drop.addEventListener('drop', e=>{
    const f = e.dataTransfer.files?.[0];
    if (f) handleFile(f);
  });
  fileInput.addEventListener('change', e=>{
    const f = e.target.files?.[0];
    if (f) handleFile(f);
  });

  // Additional file controls: add file to existing analysis and clear analysis
  const fileAdd = document.getElementById('fileAdd');
  if (fileAdd){
    fileAdd.addEventListener('change', e=>{
      const f = e.target.files?.[0];
      if (f) parseFile(f, true);
      // reset file input so the same file can be re-selected if desired
      e.target.value = '';
    });
  }
  const btnClear = document.getElementById('btnClearAnalysis');
  if (btnClear){
    btnClear.onclick = ()=>{
      analysisModels = [];
      state.xmlDoc = null;
      state.model = null;
      state.fileName = null;
      nodeMap = {};
      selectedNodes = new Set();
      // clear displays
      el('fileInfo').textContent = '';
      el('summary').innerHTML = '';
      el('activities').innerHTML = '';
      el('outline').innerHTML = '';
      el('narrative').innerText = '';
      el('mermaid').innerHTML = '';
      el('mermaidSrc').textContent = '';
      el('metrics').innerHTML = '';
      el('bestPractices').innerHTML = '';
      el('details').innerHTML = '';
      // reset stats
      ['sProcesses','sActivities','sTransitions','sInterfaces','sVars','sFaults'].forEach(id=>{
        const elem = document.getElementById(id);
        if (elem) elem.textContent = '0';
      });
    };
  }

  // --- File handling (XML or ZIP) ---
  async function handleFile(file){
    // Deprecated: use parseFile instead for new implementations
    parseFile(file, false);
  }

  async function parseZip(arrayBuffer){
    const zip = await JSZip.loadAsync(arrayBuffer);
    // Heuristics: prefer single .bwp/.xml that looks like a process definition
    let candidate = null;
    zip.forEach((path, file)=>{
      const lower = path.toLowerCase();
      if ((lower.endsWith('.bwp') || lower.endsWith('.xml')) && !path.toLowerCase().includes('schema')) {
        if (!candidate || path.length < candidate.length) candidate = path; // prefer shallow path
      }
    });
    if (!candidate) throw new Error('No .bwp/.xml found inside ZIP');
    const xmlText = await zip.file(candidate).async('string');
    await parseXmlText(xmlText);
  }

  async function parseXmlText(xmlText){
    const parser = new DOMParser();
    const doc = parser.parseFromString(xmlText, 'text/xml');
    // Basic error detection
    if (doc.getElementsByTagName('parsererror').length){
      el('summary').innerHTML = `<p class="fine" style="color:var(--bad)">XML parse error. This file doesn't look like valid XML.</p>`;
      throw new Error('XML parse error');
    }
    state.xmlDoc = doc;
    state.model = normalizeModel(doc);
    renderAll();
  }

  // --- Normalization: build a minimal, schema‑tolerant model ---
  function normalizeModel(doc){
    const all = Array.from(doc.getElementsByTagName('*'));
    const local = (n)=> (n.localName||'').toLowerCase();
    const byTag = (name)=>all.filter(n=> local(n)===name.toLowerCase());

    const processes = byTag('process').map(p=>({
      id: p.getAttribute('name') || p.getAttribute('id') || uuid('proc'),
      name: p.getAttribute('name') || p.getAttribute('label') || 'Process',
      raw: p
    }));

    const activityTags = new Set(['receive','reply','invoke','assign','throw','rethrow','wait','empty','pick','onmessage','onalarm']);
    const containerTags = new Set(['sequence','flow','scope']);

    // Containers with depth and relationships
    const containers = all.filter(n=>containerTags.has(local(n))).map(c=>({
      id: c.getAttribute('name') || c.getAttribute('id') || uuid('cnt'),
      name: c.getAttribute('name') || local(c),
      type: local(c),
      parentProcess: findAncestor(c,'process')?.getAttribute('name') || null,
      parentContainer: findAncestorAny(c, containerTags)?.getAttribute('name') || null,
      depth: depthOf(c, containerTags),
      raw: c
    }));

    const activities = all.filter(n=>{
      const ln = local(n);
      const hasType = n.hasAttribute && (n.hasAttribute('type') || n.hasAttribute('activityType'));
      return /activity$/i.test(ln) || hasType || activityTags.has(ln);
    }).map(a=>{
      // collect common attributes for richer labels
      const attrs = serializeAttrs(a);
      // partnerLink can be specified in various cases / casing
      const partnerLink = a.getAttribute('partnerLink') || a.getAttribute('partnerlink') || '';
      const operation   = a.getAttribute('operation') || '';
      const inputVar    = a.getAttribute('inputVariable') || a.getAttribute('inputvariable') || a.getAttribute('variable') || '';
      const outputVar   = a.getAttribute('outputVariable') || a.getAttribute('outputvariable') || '';
      return {
        id: a.getAttribute('name') || a.getAttribute('id') || uuid('act'),
        name: a.getAttribute('name') || a.getAttribute('label') || a.localName,
        type: a.getAttribute('type') || a.getAttribute('activityType') || local(a),
        parentProcess: findAncestor(a,'process')?.getAttribute('name') || null,
        parentScope: (findAncestor(a,'scope')?.getAttribute('name')) || (findAncestor(a,'sequence')?.getAttribute('name')) || (findAncestor(a,'flow')?.getAttribute('name')) || null,
        containerDepth: depthOf(a, containerTags),
        raw: a,
        attrs,
        partnerLink,
        operation,
        inputVar,
        outputVar
      };
    });

    const transitions = all.filter(n=>/transition|edge|link/i.test(local(n)) || (n.hasAttribute?.('from') && n.hasAttribute?.('to'))).map(t=>({
      id: t.getAttribute('name') || t.getAttribute('id') || uuid('tr'),
      from: t.getAttribute('from') || t.getAttribute('source') || t.getAttribute('start') || t.getAttribute('fromActivity') || '',
      to:   t.getAttribute('to')   || t.getAttribute('target') || t.getAttribute('end')   || t.getAttribute('toActivity')   || '',
      condition: t.getAttribute('condition') || t.getAttribute('expr') || '',
      parentProcess: findAncestor(t,'process')?.getAttribute('name') || null,
      raw: t
    }));

    const interfaces = all.filter(n=>['interface','partner','binding','endpoint','operation'].includes(local(n))).map(n=>({
      name: n.getAttribute('name') || n.localName,
      type: n.getAttribute('type') || n.localName,
      attrs: serializeAttrs(n)
    }));

    const variables = all.filter(n=>['variable','param','property','global','shared'].includes(local(n))).map(n=>({
      name: n.getAttribute('name') || n.localName,
      scope: findAncestor(n,'process')? 'process':'global',
      attrs: serializeAttrs(n)
    }));

    const faults = all.filter(n=>['fault','catch','handler','onerror'].includes(local(n))).map(n=>({
      name: n.getAttribute('name') || n.localName,
      kind: local(n),
      attrs: serializeAttrs(n)
    }));

    // Build simple hierarchical outline per process
    const hierarchy = processes.map(p=>({ name:p.name, type:'process', children: outlineChildren(p.raw) }));

    return { processes, activities, transitions, interfaces, variables, faults, hierarchy, containers };

    function outlineChildren(root){
      const kids = [];
      for (const ch of Array.from(root.children)){
        const ln = local(ch);
        if (containerTags.has(ln)){
          kids.push({ name: ch.getAttribute('name')||ln, type: ln, children: outlineChildren(ch) });
        } else if (activityTags.has(ln) || /activity$/i.test(ln) || ch.hasAttribute('type') || ch.hasAttribute('activityType')){
          kids.push({ name: ch.getAttribute('name')||ch.localName, type: ch.getAttribute('type')||ch.getAttribute('activityType')||ln, children: [] });
        }
      }
      return kids;
    }

    function depthOf(node, tagSet){
      let d = 0, p = node.parentElement;
      while(p){
        if (tagSet.has(local(p))) d++;
        if (local(p)==='process') break;
        p = p.parentElement;
      }
      return d;
    }
    function findAncestor(node, localName){ let p=node.parentElement; while(p){ if ((p.localName||'').toLowerCase()===localName) return p; p=p.parentElement; } return null; }
    function findAncestorAny(node, set){ let p=node.parentElement; while(p){ if (set.has(local(p))) return p; p=p.parentElement; } return null; }
    function serializeAttrs(node){ const o={}; if (!node?.attributes) return o; for(const a of node.attributes){ o[a.name]=a.value; } return o; }
  }

  // Parse an XML string into a normalized model without mutating global state. Returns the model or null on error.
  function parseXmlToModel(xmlText){
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, 'text/xml');
      if (doc.getElementsByTagName('parsererror').length){
        console.warn('XML parse error in parseXmlToModel');
        return null;
      }
      const model = normalizeModel(doc);
      return model;
    } catch (err){
      console.warn('parseXmlToModel failed', err);
      return null;
    }
  }

  // Unify multiple normalized models into a single model. Each model may come from a different file.
  // This function prefixes IDs to ensure uniqueness across files and merges arrays. It does not attempt
  // to resolve cross-process links or adjust parentProcess values beyond prefixing IDs. Processes and
  // containers retain their names and parentProcess references for clarity. Returns a merged model.
  function unifyModels(models){
    const result = { processes: [], activities: [], transitions: [], interfaces: [], variables: [], faults: [], hierarchy: [], containers: [] };
    models = models || [];
    models.forEach((m, idx)=>{
      const prefix = `f${idx}_`;
      // Processes
      m.processes.forEach(p=>{
        result.processes.push({ ...p, id: prefix + p.id });
      });
      // Activities
      m.activities.forEach(a=>{
        result.activities.push({ ...a, id: prefix + a.id });
      });
      // Containers
      (m.containers||[]).forEach(c=>{
        result.containers.push({ ...c, id: prefix + c.id });
      });
      // Transitions: prefix id, from, to to keep them unique; leave parentProcess as is
      m.transitions.forEach(t=>{
        result.transitions.push({ ...t, id: prefix + t.id, from: t.from ? prefix + t.from : t.from, to: t.to ? prefix + t.to : t.to });
      });
      // Interfaces, variables, faults
      result.interfaces.push(...m.interfaces);
      result.variables.push(...m.variables);
      result.faults.push(...m.faults);
      // Hierarchy: we keep as-is but wrap in a file-labeled root
      if (m.hierarchy) result.hierarchy.push(...m.hierarchy);
    });
    return result;
  }

  /**
   * Parse a file (.bwp, .xml, or .zip) into a model and integrate it into the current analysis.
   * If append is true, the model is added to the existing analysisModels; otherwise the analysis
   * is reset. After unifying models, the UI is re-rendered. Errors are shown in the file info area.
   */
  async function parseFile(file, append){
    if (!file) return;
    state.fileName = file.name;
    // Display status
    el('fileInfo').textContent = `${append ? 'Added' : 'Selected'}: ${file.name} (${Math.round(file.size/1024)} KB)`;
    try {
      const buf = await file.arrayBuffer();
      let xmlText;
      // Detect ZIP by magic header (PK\x03\x04)
      const isZip = new Uint8Array(buf, 0, 4).every((b,i)=>[0x50,0x4b,0x03,0x04][i]===b);
      if (isZip){
        const zip = await JSZip.loadAsync(buf);
        let candidate = null;
        zip.forEach((path, zfile)=>{
          const lower = path.toLowerCase();
          if ((lower.endsWith('.bwp') || lower.endsWith('.xml')) && !lower.includes('schema')){
            if (!candidate || path.length < candidate.length) candidate = path;
          }
        });
        if (!candidate) throw new Error('No .bwp/.xml found inside ZIP');
        xmlText = await zip.file(candidate).async('string');
      } else {
        xmlText = new TextDecoder().decode(buf);
      }
      const model = parseXmlToModel(xmlText);
      if (!model) throw new Error('Failed to parse XML into a model');
      if (!append) analysisModels = [];
      analysisModels.push(model);
      // unify all models
      state.model = unifyModels(analysisModels);
      renderAll();
    } catch (err){
      console.warn(err);
      el('fileInfo').textContent = 'Error: ' + err.message;
    }
  }

  function uuid(prefix){ return `${prefix}_${Math.random().toString(36).slice(2,9)}`; }

  // --- Rendering ---
  function renderAll(){
    const m = state.model;
    // Stats
    el('sProcesses').textContent = m.processes.length;
    el('sActivities').textContent = m.activities.length;
    el('sTransitions').textContent = m.transitions.length;
    el('sInterfaces').textContent = m.interfaces.length;
    el('sVars').textContent       = m.variables.length;
    el('sFaults').textContent     = m.faults.length;

    // Summary panel
    el('summary').innerHTML = buildSummaryHtml(m);

    // Activities table
    el('activities').innerHTML = buildActivitiesHtml(m);
    // Outline panel
    if (el('outline')) el('outline').innerHTML = buildOutlineHtml(m);

    // Default flow diagram
    buildFlowDiagram();

    // Generate narrative
    updateNarrative();

    // Update metrics and best-practice panels
    updateMetrics();
    updateBestPractices();
  }

  function buildSummaryHtml(m){
    const procs = m.processes.map(p=>`<li><span class="tag">Process</span> <b>${esc(p.name)}</b> <span class="fine">(${esc(p.id)})</span></li>`).join('') || '<li class="fine">No explicit <code>process</code> tags found</li>';

    const ifaces = m.interfaces.map(i=>`<li><span class="tag">${esc(i.type)}</span> <b>${esc(i.name)}</b> ${fmtAttrs(i.attrs)}</li>`).join('') || '<li class="fine">None detected</li>';

    const vars = m.variables.map(v=>`<li><span class="tag">${esc(v.scope)}</span> <b>${esc(v.name)}</b> ${fmtAttrs(v.attrs)}</li>`).join('') || '<li class="fine">None detected</li>';

    const faults = m.faults.map(f=>`<li><span class="tag">${esc(f.kind)}</span> <b>${esc(f.name)}</b> ${fmtAttrs(f.attrs)}</li>`).join('') || '<li class="fine">None detected</li>';

    return `
      <div class="grid">
        <div>
          <h3>Processes</h3>
          <ul>${procs}</ul>
        </div>
        <div>
          <h3>Interfaces / Endpoints</h3>
          <ul>${ifaces}</ul>
        </div>
      </div>
      <div class="grid" style="margin-top:10px">
        <div>
          <h3>Variables & Properties</h3>
          <ul>${vars}</ul>
        </div>
        <div>
          <h3>Faults & Handlers</h3>
          <ul>${faults}</ul>
        </div>
      </div>
    `;

    function fmtAttrs(attrs){
      const keys = Object.keys(attrs||{}).filter(k=>!['name','id','label','type'].includes(k));
      if (!keys.length) return '';
      return `<span class="fine">— ${keys.map(k=>`<span class="mono">${esc(k)}="${esc(attrs[k])}"</span>`).join(' ')}</span>`;
    }
  }

  function buildActivitiesHtml(m){
    const byType = new Map();
    for (const a of m.activities){
      const k = (a.type||'activity').toLowerCase();
      if (!byType.has(k)) byType.set(k, []);
      byType.get(k).push(a);
    }
    const groups = Array.from(byType.entries()).sort((a,b)=>b[1].length - a[1].length);
    if (!groups.length) return '<p class="fine">No activities detected.</p>';

    return groups.map(([type, items])=>{
      const rows = items.map(it=>{
        const outs = it.outBindings?.length ? `${it.outBindings.length} out` : '';
        const ins  = it.inBindings?.length ? `${it.inBindings.length} in`  : '';
        const io = [ins,outs].filter(Boolean).join(' / ');
        return `<tr>
          <td><span class="tag">${esc(type)}</span></td>
          <td><b>${esc(it.name)}</b><div class="fine">${esc(it.id)}</div></td>
          <td>${esc(it.parentProcess||'—')}</td>
          <td class="fine">${io||'—'}</td>
        </tr>`;
      }).join('');
      return `<details open>
        <summary><b>${esc(type)}</b> <span class="fine">(${items.length})</span></summary>
        <table>
          <thead><tr><th>Type</th><th>Activity</th><th>Process</th><th>I/O</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      </details>`
    }).join('');
  }

  // Build a nested HTML outline showing the process tree (sequence/flow/scope and activities)
  function buildOutlineHtml(m){
    // If no hierarchy present, fall back
    if (!m || !m.hierarchy || !m.hierarchy.length) return '<p class="fine">No outline available.</p>';
    // Recursive renderer for each node
    function renderNode(node){
      const label = `<span class="tag">${esc(node.type)}</span> <b>${esc(node.name)}</b>`;
      const children = (node.children && node.children.length)
        ? `<ul>${node.children.map(renderNode).join('')}</ul>`
        : '';
      return `<li>${label}${children}</li>`;
    }
    return `<ul>${m.hierarchy.map(renderNode).join('')}</ul>`;
  }

  // --- Diagram Builders ---
  function buildFlowDiagram(){
    const m = state.model;
    if (!m) return;
    const dir = (document.getElementById('optDir')?.value) || 'TD';
    const swim = !!document.getElementById('optSwim')?.checked;
    const lin  = !!document.getElementById('optLinearize')?.checked;
    const level = parseInt(document.getElementById('optLevel')?.value || '3', 10);
    const showService = document.getElementById('optService')?.checked;
    const showVars    = document.getElementById('optVars')?.checked;
    const showConds   = document.getElementById('optConds')?.checked;
    const seqDisplay  = (document.getElementById('optSeqDisplay')?.value) || 'annotate';
    const useColors   = !!document.getElementById('optColors')?.checked;
    const useIcons    = !!document.getElementById('optIcons')?.checked;
    const search      = (document.getElementById('searchFilter')?.value || '').trim();
    const selectedArr = Array.from(selectedNodes || []);
    const src = mermaidFlowFromModel(m, {
      dir: dir,
      swimlanes: swim,
      linearize: lin,
      level: level,
      showService: showService,
      showVars: showVars,
      showConds: showConds,
      seqDisplay: seqDisplay,
      colors: useColors,
      icons: useIcons,
      search: search,
      selected: selectedArr
    });
    setMermaid(src);
    // regenerate narrative based on current options and level
    updateNarrative();
    // Update metrics, best practices, and selected details after diagram is rebuilt
    updateMetrics();
    updateBestPractices();
    updateDetails();
  }
  function buildSequenceDiagram(){
    const src = mermaidSequenceFromModel(state.model);
    setMermaid(src);
    // clear selected details when showing sequence view
    updateDetails();
  }
  el('btnFlow').onclick = buildFlowDiagram;
  el('btnSeq').onclick  = buildSequenceDiagram;

  // Zoom handling for the rendered Mermaid diagram. Maintains a scale factor and
  // applies it to the SVG on demand. Users can zoom in/out or reset via buttons.
  let zoomScale = 1;
  function applyZoom(){
    const svg = document.querySelector('#mermaid svg');
    if (!svg) return;
    svg.style.transformOrigin = '0 0';
    svg.style.transform = `scale(${zoomScale})`;
  }

  // Attach zoom button handlers once the DOM is ready
  document.getElementById('zoomIn').onclick = ()=>{
    zoomScale = Math.min(4, zoomScale * 1.2);
    applyZoom();
  };
  document.getElementById('zoomOut').onclick = ()=>{
    zoomScale = Math.max(0.25, zoomScale / 1.2);
    applyZoom();
  };
  document.getElementById('zoomReset').onclick = ()=>{
    zoomScale = 1;
    applyZoom();
  };

  // Toggle all <details> elements within the diagram panel (#mermaid and its siblings) open or closed.
  const btnDetails = document.getElementById('btnToggleDiagramDetails');
  if (btnDetails){
    btnDetails.onclick = () => {
      // Select the Mermaid source details (immediately following #mermaid) and the appearance config details
      const srcDet = document.getElementById('mermaidSource');
      const appDet = document.getElementById('appearanceConfig');
      const dets = [];
      if (srcDet) dets.push(srcDet);
      if (appDet) dets.push(appDet);
      if (!dets.length) return;
      const allOpen = dets.every(d => d.open);
      dets.forEach(d => { d.open = !allOpen; });
      btnDetails.textContent = allOpen ? 'Expand All' : 'Collapse All';
    };
  }

  // update flowchart when options change
  document.getElementById('optDir').onchange = buildFlowDiagram;
  document.getElementById('optSwim').onchange = buildFlowDiagram;
  document.getElementById('optLinearize').onchange = buildFlowDiagram;
  document.getElementById('optLevel').onchange = buildFlowDiagram;
  document.getElementById('optService').onchange = buildFlowDiagram;
  document.getElementById('optVars').onchange = buildFlowDiagram;
  document.getElementById('optConds').onchange = buildFlowDiagram;

  // New option handlers
  document.getElementById('optColors').onchange = buildFlowDiagram;
  document.getElementById('optIcons').onchange = buildFlowDiagram;
  document.getElementById('optSeqDisplay').onchange = buildFlowDiagram;
  // Search input: trigger on input to filter diagram
  document.getElementById('searchFilter').oninput = () => {
    // Do not reset selection when searching; just rebuild diagram with highlight
    buildFlowDiagram();
  };

  function setMermaid(source){
    // Update the displayed Mermaid source code
    el('mermaidSrc').textContent = source;
    // Prepare an init directive to ensure diagrams use full width and dark theme.
    const init = "%%{init: {'flowchart': {'useMaxWidth': true}, 'theme': 'dark'} }%%\n";
    const container = el('mermaid');
    // Wrap the source in a div with class mermaid so that Mermaid.js picks it up
    container.innerHTML = '<div class="mermaid">' + init + source + '</div>';
    // Attempt to render the Mermaid diagram; catch errors to avoid breaking the UI
    try {
      mermaid.run({ querySelector: '#mermaid .mermaid' });
    } catch (e) {
      console.warn('Mermaid render error', e);
    }
    // Apply any existing zoom scale to the new SVG
    applyZoom();
  }

  function mermaidFlowFromModel(m, opts = {}){
    const dir = opts.dir || 'TD';
    const swimlanes = !!opts.swimlanes;
    const linearize = !!opts.linearize;
    const lines = [`flowchart ${dir}`];
    const nid = (name)=> esc(name||'').replace(/[^a-zA-Z0-9_]/g,'_').slice(0,40) || uuid('N');

    // Group activities by process
    const byProc = new Map();
    for (const a of m.activities){
      const p = a.parentProcess || 'Main';
      if (!byProc.has(p)) byProc.set(p, []);
      byProc.get(p).push(a);
    }

    for (const [proc, acts] of byProc){
      const procId = nid(`cluster_${proc}`);
      if (swimlanes){ lines.push(`subgraph ${procId}[${esc(proc)}]`); }

      // group by scope if swimlanes
      const byScope = new Map();
      for (const a of acts){
        const s = a.parentScope || 'default';
        if (!byScope.has(s)) byScope.set(s, []);
        byScope.get(s).push(a);
      }
      if (swimlanes){
        for (const [scope, items] of byScope){
          const sid = nid(`scope_${proc}_${scope}`);
          lines.push(`subgraph ${sid}[${esc(scope==='default'?'(no scope)':scope)}]`);
          for (const a of items){
            const id = nid(`${proc}_${a.id}`);
            lines.push(`${id}[\"${esc(a.name)}\\n<small>${esc(a.type)}</small>\"]`);
          }
          lines.push('end');
        }
      } else {
        for (const a of acts){
          const id = nid(`${proc}_${a.id}`);
          lines.push(`${id}[\"${esc(a.name)}\\n<small>${esc(a.type)}</small>\"]`);
        }
      }

      if (swimlanes){ lines.push('end'); }
    }

    // Edges
    if (linearize){
      // simple document-order edges per process
      const ordered = [...m.activities].sort((a,b)=> (a.raw?.sourceIndex || 0) - (b.raw?.sourceIndex || 0));
      for (let i=0; i<ordered.length-1; i++){
        const from = nid(`${ordered[i].parentProcess||'Main'}_${ordered[i].id}`);
        const to   = nid(`${ordered[i+1].parentProcess||'Main'}_${ordered[i+1].id}`);
        lines.push(`${from} --> ${to}`);
      }
    } else {
      for (const t of m.transitions){
        const from = nid(`${t.parentProcess||'Main'}_${t.from||t.id+'f'}`);
        const to   = nid(`${t.parentProcess||'Main'}_${t.to||t.id+'t'}`);
        const label = t.condition ? `|${esc(t.condition)}|` : '';
        lines.push(`${from} -->${label} ${to}`);
      }
    }

    if (lines.length<=1){ lines.push('A[Start]-->B[No transitions detected];'); }
    return lines.join('\n');
  }

  // Override mermaidFlowFromModel to support multiple abstraction levels
  mermaidFlowFromModel = function(m, opts = {}) {
    const dir = opts.dir || 'TD';
    const swim = !!opts.swimlanes;
    const linearize = !!opts.linearize;
    const level = Number.isFinite(opts.level) ? opts.level : 3;
    // Enhanced options: showService (partner link/operation), showVars (input/output vars), showConds (edge conditions)
    const showService = opts.showService !== false;
    const showVars    = !!opts.showVars;
    const showConds   = opts.showConds !== false;
    // Sequence display options: 'show', 'annotate', 'hide'
    const seqDisplay = opts.seqDisplay || 'annotate';
    // Node coloring and icon options
    const useColors = !!opts.colors;
    const useIcons  = !!opts.icons;
    const searchTerm = (opts.search || '').toLowerCase();
    const selectedIds = new Set(opts.selected || []);
    const lines = ["flowchart "+dir];
    const classLines = [];
    const assignLines = [];
    const nid = (name) => esc(name||'').replace(/[^a-zA-Z0-9_]/g,'_').slice(0,40) || uuid('N');
    // Reset nodeMap for interactive lookup
    nodeMap = {};
    // Helper to count descendant activities for any container-like node.  This walks
    // through the DOM tree and counts immediate and nested activities so we can
    // annotate containers with the number of contained steps.  It memoises
    // results to avoid repeated work.
    const seqCountCache = new Map();
    function countDescActivities(containerRaw){
      if (!containerRaw) return 0;
      if (seqCountCache.has(containerRaw)) return seqCountCache.get(containerRaw);
      let count = 0;
      const q = [containerRaw];
      while(q.length){
        const n = q.pop();
        for (const ch of Array.from(n.children||[])){
          const ln = (ch.localName||'').toLowerCase();
          // Count any node that looks like an activity or has a type/activityType attribute
          if (/activity$/.test(ln) || ch.getAttribute?.('type') || ch.getAttribute?.('activityType') || /receive|reply|invoke|assign|throw|rethrow|wait|empty|pick|onmessage|onalarm/.test(ln)){
            count++;
          }
          // always traverse deeper
          q.push(ch);
        }
      }
      seqCountCache.set(containerRaw, count);
      return count;
    }
    // Helper: read user-defined appearance (color and icon) from inputs
    function getAppearanceFor(cat){
      const key = cat.charAt(0).toUpperCase() + cat.slice(1);
      const colInput = document.getElementById('color'+key);
      const iconInput= document.getElementById('icon'+key);
      const colorVal = colInput ? colInput.value || '' : '';
      const iconVal  = iconInput ? iconInput.value || '' : '';
      return { color: colorVal, icon: iconVal };
    }
    // Contrast color for text readability
    function contrastColor(hex){
      if (!hex || !/^#?[0-9a-fA-F]{6}$/.test(hex)) return '#ffffff';
      const h = hex.replace('#','');
      const r = parseInt(h.substring(0,2),16);
      const g = parseInt(h.substring(2,4),16);
      const b = parseInt(h.substring(4,6),16);
      const yiq = (r*299 + g*587 + b*114) / 1000;
      return yiq >= 128 ? '#000000' : '#ffffff';
    }
    // Dynamic class definitions for categories based on selected colors
    const dynamicClassDefs = {};
    if (useColors){
      // Map human categories to mermaid class keys (defined in categoryClassMap)
      const catToClass = { service:'svc', transformation:'transf', decision:'dec', error:'err', loop:'loop', timer:'tim', other:'oth' };
      ['service','transformation','decision','error','loop','timer','other'].forEach(cat => {
        const ap = getAppearanceFor(cat);
        if (ap.color){
          const contrast = contrastColor(ap.color);
          const classKey = catToClass[cat] || cat;
          dynamicClassDefs[classKey] = `fill:${ap.color},stroke:${ap.color},color:${contrast}`;
        }
      });
    }
    // Always define highlight and selected classes
    dynamicClassDefs['highlight'] = 'stroke:#ffd166,stroke-width:4px';
    dynamicClassDefs['selected']  = 'stroke:#ffffff,stroke-width:4px';

    // Build a map from raw DOM nodes to activity objects so we can access
    // input/output variables captured during normalization. This is used to
    // enrich node labels when the Variables option is enabled.
    const rawToAct = new Map();
    if (m && Array.isArray(m.activities)){
      for (const act of m.activities){ if (act.raw) rawToAct.set(act.raw, act); }
    }
    // Group activities and containers by process
    const byProcActs = new Map();
    for (const a of m.activities){
      const p = a.parentProcess || 'Main';
      if (!byProcActs.has(p)) byProcActs.set(p, []);
      byProcActs.get(p).push(a);
    }
    const byProcCnt = new Map();
    for (const c of (m.containers || [])){
      const p = c.parentProcess || 'Main';
      if (!byProcCnt.has(p)) byProcCnt.set(p, []);
      byProcCnt.get(p).push(c);
    }
    // Predefine class definitions if coloring enabled or highlight/selected used
    const classDefs = {
      svc:   'fill:#3b6cff,stroke:#3b6cff,color:#ffffff',
      transf:'fill:#40d19a,stroke:#40d19a,color:#001c17',
      dec:   'fill:#ffd166,stroke:#ffd166,color:#352b00',
      err:   'fill:#ff6b6b,stroke:#ff6b6b,color:#330000',
      loop:  'fill:#a084ca,stroke:#a084ca,color:#26003d',
      tim:   'fill:#9e4770,stroke:#9e4770,color:#330018',
      oth:   'fill:#5b6988,stroke:#5b6988,color:#ffffff',
      highlight: 'stroke:#ffd166,stroke-width:4px',
      selected:  'stroke:#ffffff,stroke-width:4px'
    };
    const categoryClassMap = {
      service:'svc',
      transformation:'transf',
      decision:'dec',
      error:'err',
      loop:'loop',
      timer:'tim',
      other:'oth'
    };
    // Build diagrams per process
    for (const proc of new Set([...(byProcActs.keys()), ...(byProcCnt.keys())])) {
      const procId = nid(`cluster_${proc}`);
      const acts = byProcActs.get(proc) || [];
      const cnts = byProcCnt.get(proc) || [];
      const items = [];
      if (level === 0) {
        items.push({ id: nid(`${proc}_PROC`), label: esc(proc), type:'process', raw:null, cat:'other' });
      } else if (level === 1) {
        if (cnts.length){
          for (const c of cnts){ if (c.depth === 0) {
              // handle sequence display
              if (c.type === 'sequence' && seqDisplay === 'hide') continue;
              let label = `${c.name}\n<small>${c.type}</small>`;
              if (c.type === 'sequence' && seqDisplay === 'annotate'){
                const steps = countDescActivities(c.raw);
                label = `${c.name} (${steps})\n<small>${c.type}</small>`;
              }
              items.push({ id: nid(`${proc}_${c.id}`), label: label, type:'container', raw:c.raw, cat:'other', originalType: c.type });
          } }
        } else {
          items.push({ id: nid(`${proc}_PROC`), label: esc(proc), type:'process', raw:null, cat:'other' });
        }
      } else if (level === 2) {
        for (const c of cnts){ if (c.depth === 0) {
            if (c.type === 'sequence' && seqDisplay === 'hide') {
              // skip
            } else {
              let label = `${c.name}\n<small>${c.type}</small>`;
              if (c.type === 'sequence' && seqDisplay === 'annotate'){
                const steps = countDescActivities(c.raw);
                label = `${c.name} (${steps})\n<small>${c.type}</small>`;
              }
              items.push({ id: nid(`${proc}_${c.id}`), label: label, type:'container', raw:c.raw, cat:'other', originalType: c.type });
            }
        } }
        for (const a of acts){ if ((a.containerDepth || 0) === 0) {
            items.push({ id: nid(`${proc}_${a.id}`), label: `${a.name}\n<small>${a.type}</small>`, type:'activity', raw:a.raw, cat: categorizeType(a.type) });
        } }
      } else {
        for (const a of acts){
          items.push({ id: nid(`${proc}_${a.id}`), label: `${a.name}\n<small>${a.type}</small>`, type:'activity', raw:a.raw, cat: categorizeType(a.type) });
        }
      }
      // Prior to rendering, handle repeating nodes (sequences, children, etc.).
      // Compute counts of items by type/originalType/localName to identify repetitive nodes.
      const typeCounts = {};
      for (const itm of items){
        const raw = itm.raw;
        // Determine a key based on originalType, localName, or category
        let key;
        if (itm.originalType){
          key = itm.originalType.toLowerCase();
        } else if (raw && raw.localName){
          key = raw.localName.toLowerCase();
        } else if (itm.type){
          key = String(itm.type).toLowerCase();
        } else {
          key = 'unknown';
        }
        typeCounts[key] = (typeCounts[key] || 0) + 1;
      }
      // Apply hide/annotate behaviour to repeating nodes when seqDisplay != 'show'
      if (seqDisplay !== 'show'){
        const pruned = [];
        for (const itm of items){
          let key;
          if (itm.originalType){ key = itm.originalType.toLowerCase(); }
          else if (itm.raw && itm.raw.localName){ key = itm.raw.localName.toLowerCase(); }
          else if (itm.type){ key = String(itm.type).toLowerCase(); }
          else { key = 'unknown'; }
          const count = typeCounts[key] || 1;
          // Determine whether this node is considered repetitive (count >1)
          const isRepeating = count > 1;
          if (isRepeating){
            if (seqDisplay === 'hide'){
              // Skip this item entirely
              continue;
            } else if (seqDisplay === 'annotate'){
              // Annotate the label: for containers (any node with children) use descendant count; otherwise use duplicate count.
              const parts = itm.label.split('\n');
              const firstLine = parts[0];
              // Avoid double annotation if parentheses already present at end of first line
              if (!/\(\d+\)$/.test(firstLine.trim())){
                if (itm.raw && itm.raw.children && itm.raw.children.length > 0){
                  const steps = countDescActivities(itm.raw);
                  parts[0] = `${firstLine} (${steps})`;
                } else {
                  parts[0] = `${firstLine} (${count})`;
                }
                itm.label = parts.join('\n');
              }
            }
          }
          pruned.push(itm);
        }
        items.length = 0;
        items.push(...pruned);
      }

      // Start process subgraph if swimlanes
      if (swim) lines.push(`subgraph ${procId}[${esc(proc)}]`);
      // Render items
      for (const it of items){
        // NodeMap mapping for interactive details
        nodeMap[it.id] = it;
        // Build node label with optional service, variables, icons
        let lbl = `${it.label}`;
        // Prepend icon to the first line if icons are enabled
        if (useIcons){
          const ap = getAppearanceFor(it.cat || 'other');
          const ic = (ap && ap.icon) ? ap.icon.trim() : '';
          if (ic){
            const parts = lbl.split('\n');
            parts[0] = `${ic} ${parts[0]}`;
            lbl = parts.join('\n');
          }
        }
        // Append service info and variables if requested
        if (it.raw && (showService || showVars)){
          const a = it.raw;
          const actObj = rawToAct.get(a) || null;
          const pl = a.getAttribute && (a.getAttribute('partnerLink') || a.getAttribute('partnerlink') || '');
          const op = a.getAttribute && a.getAttribute('operation');
          // Prefer normalized inputVar/outputVar if available; fallback to raw attributes
          let inV  = actObj && actObj.inputVar || '';
          let outV = actObj && actObj.outputVar || '';
          if (!inV)  inV  = a.getAttribute && (a.getAttribute('inputVariable') || a.getAttribute('inputvariable') || a.getAttribute('variable'));
          if (!outV) outV = a.getAttribute && (a.getAttribute('outputVariable') || a.getAttribute('outputvariable'));
          const extras = [];
          if (showService && (pl || op)){
            const svc = `${pl || ''}${pl && op ? ' ' : ''}${op || ''}`.trim(); if (svc) extras.push(svc);
          }
          if (showVars && (inV || outV)){
            const vline = `${inV || ''}${(inV && outV) ? '→' : ''}${outV || ''}`.trim(); if (vline) extras.push(vline);
          }
          if (extras.length){
            const parts = lbl.split('\n');
            const first = parts.shift();
            const last = parts.pop() || '';
            lbl = `${first}\n${extras.join('\n')}\n${last}`;
          }
        }
        // Compose node definition
        lines.push(`${it.id}["${lbl}"]`);
        // Click directive for interactive step-through
        lines.push(`click ${it.id} mermaidNodeClick`);
        // Assign classes for categories
        const catKey = categoryClassMap[it.cat] || 'oth';
        if (useColors){ assignLines.push(`class ${it.id} ${catKey}`); }
        // Search highlight
        if (searchTerm){
          const n = (it.raw?.getAttribute && (it.raw.getAttribute('name') || it.raw.getAttribute('label')) || it.label || '').toLowerCase();
          const t = (it.raw?.getAttribute && (it.raw.getAttribute('type') || it.raw.getAttribute('activityType')) || it.type || '').toLowerCase();
          const plx = it.raw?.getAttribute && (it.raw.getAttribute('partnerLink') || it.raw.getAttribute('partnerlink')) || '';
          const op2 = it.raw?.getAttribute && it.raw.getAttribute('operation') || '';
          const combined = `${n} ${t} ${plx} ${op2}`;
          if (combined.includes(searchTerm)){
            assignLines.push(`class ${it.id} highlight`);
          }
        }
        // Selected nodes class
        if (selectedIds.has(it.id)){
          assignLines.push(`class ${it.id} selected`);
        }
      }
      if (swim) lines.push('end');
      // Edges
      if (level < 3 || linearize) {
        // Document-order edges
        const ordered = items.slice().sort((a,b) => {
          if (a.raw && b.raw && a.raw.compareDocumentPosition) {
            const cmp = a.raw.compareDocumentPosition(b.raw);
            if (cmp & 2) return 1;
            if (cmp & 4) return -1;
          }
          return 0;
        });
        for (let i=0; i<ordered.length-1; i++){
          lines.push(`${ordered[i].id} --> ${ordered[i+1].id}`);
        }
      } else {
        for (const t of m.transitions){
          const from = nid(`${t.parentProcess || proc}_${t.from || t.id + 'f'}`);
          const to   = nid(`${t.parentProcess || proc}_${t.to || t.id + 't'}`);
          let lbl = '';
          if (showConds && t.condition){ lbl = `|${esc(t.condition)}|`; }
          lines.push(`${from} -->${lbl} ${to}`);
        }
      }
    }
    // Append class definitions and assignments if needed
    if (useColors || searchTerm || selectedIds.size){
      // dynamic class definitions based on selected colors
      for (const key in dynamicClassDefs){
        classLines.push(`classDef ${key} ${dynamicClassDefs[key]}`);
      }
    }
    const output = lines.concat(classLines, assignLines);
    if (output.length <= 1){ output.push('A[Start]-->B[No transitions detected];'); }
    return output.join('\n');
  };

  function mermaidSequenceFromModel(m){
    // Very heuristic: treat interfaces as participants; activities as messages in order.
    const parts = new Set(m.interfaces.map(i=>i.name || i.type));
    if (!parts.size) parts.add('System');

    const lines = ["sequenceDiagram"]; 
    for (const p of parts){ lines.push(`participant ${esc(p).replace(/\s+/g,'_')} as ${esc(p)}`); }

    // naive ordering by document order
    const orderedActs = m.activities.slice(0,50); // cap to keep diagram readable
    for (const a of orderedActs){
      const src = a.inBindings?.[0]?.partner || a.inBindings?.[0]?.endpoint || 'System';
      const dst = a.outBindings?.[0]?.partner || a.outBindings?.[0]?.endpoint || 'System';
      const s = esc(String(src)).replace(/\s+/g,'_');
      const d = esc(String(dst)).replace(/\s+/g,'_');
      lines.push(`${s}->>${d}: ${esc(a.name)} [${esc(a.type)}]`);
    }

    if (lines.length===1){
      lines.push('Note over System: No interfaces/activities detected for sequence view');
    }
    return lines.join('\n');
  }

  function findByNearName(list, t, key){
    // try to locate activity id/name by partial match
    const val = t[key]; if (!val) return null;
    const lc = val.toLowerCase();
    return list.find(a=> (a.id||'').toLowerCase()===lc || (a.name||'').toLowerCase()===lc)?.id || null;
  }

  // --- Exporters ---
  el('btnExportMD').onclick = ()=> exportMarkdown();
  el('btnExportHTML').onclick = ()=> exportHtml();

  // Additional buttons: Data Flow, Export PNG, Export PDF
  document.getElementById('btnDataFlow').onclick = buildDataFlowDiagram;
  document.getElementById('btnExportPNG').onclick = exportPNG;
  document.getElementById('btnExportPDF').onclick = exportPDF;

  // Expand/Collapse all sections in the Activities list
  const btnToggle = document.getElementById('btnToggleDetails');
  if (btnToggle){
    btnToggle.onclick = ()=>{
      const detailEls = document.querySelectorAll('#activities details');
      if (!detailEls || detailEls.length===0) return;
      // Determine if all are currently open
      const allOpen = Array.from(detailEls).every(d=>d.open);
      detailEls.forEach(d=>{ d.open = !allOpen; });
      // Update button label
      btnToggle.textContent = allOpen ? 'Expand All' : 'Collapse All';
    };
  }

  function exportMarkdown(){
    const m = state.model; if (!m) return;
    const name = (state.fileName||'process').replace(/\.[^.]+$/,'');
    const md = `# BusinessWorks Process Documentation\\n\\n`+
`**Source file:** ${esc(name)}\\n\\n`+
`## Summary\\n`+
`- Processes: ${m.processes.length}\\n`+
`- Activities: ${m.activities.length}\\n`+
`- Transitions: ${m.transitions.length}\\n`+
`- Interfaces: ${m.interfaces.length}\\n`+
`- Variables: ${m.variables.length}\\n`+
`- Faults: ${m.faults.length}\\n\\n`+
`## Processes\\n`+
 m.processes.map(p=>`- **${p.name}** (${p.id})`).join('\\n') + `\\n\\n`+
`## Interfaces\\n`+
 (m.interfaces.length? m.interfaces.map(i=>`- **${i.name}** (${i.type})`).join('\\n'): '_None_') + `\\n\\n`+
`## Variables\\n`+
 (m.variables.length? m.variables.map(v=>`- **${v.name}** (${v.scope})`).join('\\n'): '_None_') + `\\n\\n`+
`## Faults & Handlers\\n`+
 (m.faults.length? m.faults.map(f=>`- **${f.name}** (${f.kind})`).join('\\n'): '_None_') + `\\n\\n`+
`## Activities (by type)\\n`+
 groupBy(m.activities,a=>a.type).map(([type, items])=>`### ${type}\\n` + items.map(it=>`- **${it.name}** — id: ${it.id} — process: ${it.parentProcess||'Main'}`).join('\\n')).join('\\n\\n') + `\\n\\n`+
`## Flowchart (Mermaid)\\n`+
'```mermaid\\n'+ mermaidFlowFromModel(m) + '\\n```\\n\\n' +
`## Sequence (Mermaid)\\n`+
'```mermaid\\n'+ mermaidSequenceFromModel(m) + '\\n```\\n';

    const blob = new Blob([md], {type:'text/markdown;charset=utf-8'});
    saveAs(blob, `${name}_documentation.md`);
  }

  function exportHtml(){
    const m = state.model; if (!m) return;
    const name = (state.fileName || 'process').replace(/\.[^.]+$/,'');
    const flow = mermaidFlowFromModel(m);
    const seq  = mermaidSequenceFromModel(m);
    const parts = [];
    // Document head with title and external scripts
    parts.push('<!doctype html><html><head><meta charset="utf-8"><title>'+esc(name)+' – Documentation</title>');
    // Embed external Mermaid script. Break up the word "script" so the containing
    // HTML parser does not terminate this parent <script> prematurely.
    parts.push('<scr'+'ipt src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></scr'+'ipt>');
    // Apply basic styling and ensure diagrams are responsive and scrollable
    parts.push('<style>body{font-family:ui-sans-serif,system-ui;max-width:900px;margin:20px auto;padding:0 16px;} pre{background:#f7f7f9;padding:12px;border-radius:8px;overflow:auto} .mermaid svg{width:100%;height:auto;max-width:none;} .stage{min-height:520px;overflow:auto;border:1px solid #e0e0e0;border-radius:12px;padding:8px;margin-bottom:24px;}</style>');
    parts.push('</head><body>');
    // Summary header
    parts.push('<h1>'+esc(name)+' – BusinessWorks Documentation</h1>');
    parts.push('<p><b>Generated:</b> '+new Date().toLocaleString()+'</p>');
    parts.push('<h2>Summary</h2>');
    parts.push('<ul>');
    parts.push('<li>Processes: '+m.processes.length+'</li>');
    parts.push('<li>Activities: '+m.activities.length+'</li>');
    parts.push('<li>Transitions: '+m.transitions.length+'</li>');
    parts.push('<li>Interfaces: '+m.interfaces.length+'</li>');
    parts.push('<li>Variables: '+m.variables.length+'</li>');
    parts.push('<li>Faults: '+m.faults.length+'</li>');
    parts.push('</ul>');
    // Flowchart and sequence diagrams. Wrap in a .stage container for min-height and scrolling.
    parts.push('<h2>Flowchart</h2><div class="stage"><div class="mermaid">%%{init: {\'flowchart\': {\'useMaxWidth\': true}, \'theme\': \'default\'} }%%\n'+flow.replaceAll('<','&lt;')+'</div></div>');
    parts.push('<h2>Sequence</h2><div class="stage"><div class="mermaid">%%{init: {\'flowchart\': {\'useMaxWidth\': true}, \'theme\': \'default\'} }%%\n'+seq.replaceAll('<','&lt;')+'</div></div>');
    // Activities grouped by type
    parts.push('<h2>Activities (by type)</h2>');
    parts.push(groupBy(m.activities, a=>a.type).map(([type, items]) => {
      return '<h3>'+esc(type)+'</h3><ul>' + items.map(it => '<li><b>'+esc(it.name)+'</b> — id: '+esc(it.id)+' — process: '+esc(it.parentProcess || 'Main')+'</li>').join('') + '</ul>';
    }).join(''));
    // Initialize Mermaid in exported document and render diagrams. Use broken-up tags to avoid ending the parent script.
    parts.push('<scr'+'ipt>try{mermaid.initialize({startOnLoad:false,theme:"default",flowchart:{useMaxWidth:true,htmlLabels:true}});mermaid.run({querySelector:".mermaid"});}catch(e){console.error(e);}</scr'+'ipt>');
    parts.push('</body></html>');
    const html = parts.join('');
    const blob = new Blob([html], { type:'text/html;charset=utf-8' });
    saveAs(blob, `${name}_documentation.html`);
  }

  function esc(s){ return String(s).replace(/[&<>]/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c])); }
  function groupBy(list, fn){
    const m = new Map();
    for (const item of list){
      const k = fn(item) || 'unknown';
      if (!m.has(k)) m.set(k, []);
      m.get(k).push(item);
    }
    return Array.from(m.entries());
  }

  // --- Complexity metrics and best-practice checks ---
  /**
   * Update the complexity metrics panel. Computes counts of activity categories, number of parallel
   * branches, and maximum nesting depth from the current unified model. Displays the results in
   * the #metrics element.
   */
  function updateMetrics(){
    const m = state.model;
    const metricsDiv = document.getElementById('metrics');
    if (!metricsDiv){ return; }
    if (!m){ metricsDiv.innerHTML = '<p class="fine">No data.</p>'; return; }
    // Count categories of activities
    const counts = { service:0, transformation:0, decision:0, error:0, loop:0, timer:0, other:0 };
    let maxDepth = 0;
    (m.containers||[]).forEach(c=>{ if (c.depth>maxDepth) maxDepth = c.depth; });
    for (const a of m.activities){
      const cat = categorizeType(a.type);
      if (counts.hasOwnProperty(cat)) counts[cat]++; else counts.other++;
    }
    // Parallel branches: count number of extra branches in flow containers
    let parallel = 0;
    (m.containers||[]).forEach(c=>{
      if (c.type==='flow' && c.raw && c.raw.children){ const n = Array.from(c.raw.children).filter(ch=> ch.nodeType===1).length; if (n>1) parallel += (n - 1); }
    });
    const html = `<ul>`+
      `<li>Service calls: ${counts.service}</li>`+
      `<li>Transformations: ${counts.transformation}</li>`+
      `<li>Decisions: ${counts.decision}</li>`+
      `<li>Error/throws: ${counts.error}</li>`+
      `<li>Loops/timers: ${counts.loop + counts.timer}</li>`+
      `<li>Parallel branches: ${parallel}</li>`+
      `<li>Max depth of nested scopes: ${maxDepth}</li>`+
      `</ul>`;
    metricsDiv.innerHTML = html;
  }

  /**
   * Check for simple best-practice violations and display warnings in #bestPractices.
   * Heuristics include missing fault handlers, deep nesting, and possible hard-coded credentials.
   */
  function updateBestPractices(){
    const m = state.model;
    const bpDiv = document.getElementById('bestPractices');
    if (!bpDiv){ return; }
    if (!m){ bpDiv.innerHTML = '<p class="fine">No data.</p>'; return; }
    const warnings = [];
    // 1. No fault handlers
    if (!m.faults || m.faults.length===0) warnings.push('No fault or error handlers detected.');
    // 2. Deep nesting
    let maxDepth = 0;
    (m.containers||[]).forEach(c=>{ if (c.depth>maxDepth) maxDepth = c.depth; });
    if (maxDepth >= 4) warnings.push(`Processes have deep nesting (depth ${maxDepth}). Consider refactoring.`);
    // 3. Hard-coded credentials in attribute names or values
    const credRegex = /password|secret|token|credential/i;
    for (const a of m.activities){
      const attrs = a.attrs || {};
      for (const k in attrs){
        const val = String(attrs[k]);
        if (credRegex.test(k) || credRegex.test(val)){
          warnings.push(`Possible credential exposure in activity <b>${esc(a.name)}</b> (${esc(k)}="${esc(val)}").`);
        }
      }
    }
    if (!warnings.length) warnings.push('No issues detected.');
    bpDiv.innerHTML = '<ul>'+warnings.map(w=>'<li>'+w+'</li>').join('')+'</ul>';
  }

  // Helper to categorize activity types into coarse categories for coloring and metrics
  function categorizeType(t){
    const lt = (t||'').toLowerCase();
    if (/receive|reply|invoke/.test(lt)) return 'service';
    if (/assign|map|transform/.test(lt)) return 'transformation';
    if (/if|switch|choice|pick/.test(lt)) return 'decision';
    if (/throw|fault|rethrow|catch|error|onerror/.test(lt)) return 'error';
    if (/while|repeatuntil|foreach|loop/.test(lt)) return 'loop';
    if (/wait|alarm|sleep|timer/.test(lt)) return 'timer';
    return 'other';
  }

  // --- Data Flow Diagram builder ---
  function buildDataFlowDiagram(){
    const m = state.model;
    if (!m){ return; }
    const lines = ['flowchart TD'];
    const nid = (name)=> esc(name||'').replace(/[^a-zA-Z0-9_]/g,'_').slice(0,40) || uuid('N');
    // Collect variable names from inputVar and outputVar across activities
    const varSet = new Set();
    for (const a of m.activities){
      if (a.inputVar) varSet.add(a.inputVar);
      if (a.outputVar) varSet.add(a.outputVar);
    }
    const varIds = {};
    varSet.forEach(v=>{
      varIds[v] = nid('var_'+v);
      lines.push(`${varIds[v]}(( ${esc(v)} ))`);
    });
    // Activity nodes
    const actIds = {};
    m.activities.forEach(a=>{
      actIds[a.id] = nid('act_'+a.id);
      lines.push(`${actIds[a.id]}[${esc(a.name)}]`);
    });
    // Edges from variables to activities (input) and activities to variables (output)
    m.activities.forEach(a=>{
      const aId = actIds[a.id];
      if (a.inputVar && varIds[a.inputVar]) lines.push(`${varIds[a.inputVar]} --> ${aId}`);
      if (a.outputVar && varIds[a.outputVar]) lines.push(`${aId} --> ${varIds[a.outputVar]}`);
    });
    if (lines.length === 1) lines.push('A[No variables detected]');
    const src = lines.join('\n');
    setMermaid(src);
    // Data flow diagrams don't need narrative; update narrative pane accordingly
    const nar = document.getElementById('narrative');
    if (nar) nar.innerText = 'Data flow diagram shown.';
  }

  // --- Export to PNG and PDF using dom-to-image and jsPDF ---
  async function exportPNG(){
    const node = document.getElementById('mermaid');
    if (!node || !window.domtoimage){ console.warn('dom-to-image library not loaded'); return; }
    try {
      const blob = await domtoimage.toBlob(node);
      saveAs(blob, (state.fileName || 'diagram') + '.png');
    } catch (err){ console.warn('PNG export failed', err); }
  }
  async function exportPDF(){
    const node = document.getElementById('mermaid');
    if (!node || !window.domtoimage || !window.jspdf){ console.warn('dom-to-image or jsPDF not loaded'); return; }
    try {
      const dataUrl = await domtoimage.toPng(node);
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({ orientation: 'landscape' });
      const img = pdf.getImageProperties(dataUrl);
      const pdfWidth  = pdf.internal.pageSize.getWidth();
      const pdfHeight = (img.height * pdfWidth) / img.width;
      pdf.addImage(dataUrl, 'PNG', 0, 0, pdfWidth, pdfHeight);
      pdf.save((state.fileName || 'diagram') + '.pdf');
    } catch (err){ console.warn('PDF export failed', err); }
  }

  // --- Narrative generation ---
  // Build a simple natural-language narrative describing the workflow at the current level
  function generateNarrative(m, opts = {}){
    // Produce a human‑readable description of each process. Focus on the
    // high‑level structure rather than listing every step. Summarise sequences
    // and flows by naming their immediate children and report standalone
    // activities. Avoid enumerating too many names; if more than four children,
    // mention the count instead.  If no processes exist, return a message.
    if (!m || !m.processes || !m.processes.length) return 'No process detected.';
    const paragraphs = [];
    for (const p of m.processes){
      const procName = p.name || 'process';
      // Collect top-level containers and activities for this process
      const topContainers = (m.containers || []).filter(c => (c.parentProcess || null) === p.name && (c.depth || 0) === 0);
      const topActivities = (m.activities || []).filter(a => (a.parentProcess || null) === p.name && ((a.containerDepth || 0) === 0));
      // To preserve ordering, combine containers and activities by their document position
      const items = [];
      // Use raw nodes to compute ordering
      for (const c of topContainers){ items.push({ kind:'container', obj:c, raw:c.raw }); }
      for (const a of topActivities){ items.push({ kind:'activity', obj:a, raw:a.raw }); }
      // Sort by document order if possible
      items.sort((x,y) => {
        const xr = x.raw, yr = y.raw;
        if (xr && yr && xr.compareDocumentPosition){
          const cmp = xr.compareDocumentPosition(yr);
          if (cmp & 2) return 1;
          if (cmp & 4) return -1;
        }
        return 0;
      });
      const phrases = [];
      for (const [idx, item] of items.entries()){
        if (item.kind === 'container'){
          const c = item.obj;
          const type = (c.type || '').toLowerCase();
          // immediate children under this container
          const children = (m.activities || []).filter(a => (a.parentProcess || null) === p.name && a.parentScope === c.name);
          const names = children.map(a => a.name).filter(Boolean);
          // Build description based on container type
          let desc = '';
          if (type === 'sequence'){
            if (names.length === 0){
              desc = `a sequence (${c.name})`;
            } else if (names.length <= 4){
              desc = `a sequence with ${names.length} step${names.length > 1 ? 's' : ''}: ${names.join(', ')}`;
            } else {
              desc = `a sequence containing ${names.length} activities`;
            }
          } else if (type === 'flow'){
            if (names.length === 0){
              desc = `a flow (${c.name})`;
            } else if (names.length <= 4){
              desc = `a parallel flow branching to ${names.join(', ')}`;
            } else {
              desc = `a parallel flow with ${names.length} branches`;
            }
          } else if (type === 'scope'){
            if (names.length){
              desc = `a scope (${c.name}) containing ${names.join(', ')}`;
            } else {
              desc = `a scope named ${c.name}`;
            }
          } else {
            if (names.length){
              desc = `${type} ${c.name} containing ${names.join(', ')}`;
            } else {
              desc = `${type} ${c.name}`;
            }
          }
          phrases.push(desc);
        } else if (item.kind === 'activity'){
          const a = item.obj;
          const t = (a.type || '').toLowerCase();
          const n = a.name;
          if (n && t){
            phrases.push(`the ${t} activity ${n}`);
          } else if (n){
            phrases.push(`the activity ${n}`);
          }
        }
      }
      // Compose the narrative sentence for this process
      if (phrases.length){
        let sentence = `The process "${esc(procName)}" begins with `;
        phrases.forEach((ph, i) => {
          if (i === 0){ sentence += ph; }
          else if (i === phrases.length - 1){ sentence += ' and ' + ph; }
          else { sentence += ', ' + ph; }
        });
        sentence += '.';
        paragraphs.push(sentence);
      } else {
        paragraphs.push(`The process "${esc(procName)}" contains no top-level activities or containers.`);
      }
    }
    return paragraphs.join('\n');
  }

  function updateNarrative(){
    if (!state || !state.model) return;
    const showService = document.getElementById('optService')?.checked;
    const showVars    = document.getElementById('optVars')?.checked;
    const narrative = generateNarrative(state.model, {showService: showService, showVars: showVars});
    const container = document.getElementById('narrative');
    if (container) container.innerText = narrative;
  }

  // --- Interactive selection and details ---
  // Called by Mermaid when a node is clicked. Toggles selection of the node and updates the diagram and details panel.
  window.mermaidNodeClick = function(id){
    if (!id) return;
    if (selectedNodes.has(id)) selectedNodes.delete(id); else selectedNodes.add(id);
    buildFlowDiagram();
    updateDetails();
  };

  // Update the details panel (#details) with information about selected nodes
  function updateDetails(){
    const detailsDiv = document.getElementById('details');
    if (!detailsDiv) return;
    if (!selectedNodes || selectedNodes.size === 0){ detailsDiv.innerHTML = '<p class="fine">No activities selected.</p>'; return; }
    const html = [];
    selectedNodes.forEach(id=>{
      const it = nodeMap[id];
      if (!it) return;
      const raw = it.raw;
      const name = raw?.getAttribute && (raw.getAttribute('name') || raw.getAttribute('label')) || it.label || id;
      const type = it.originalType || it.type;
      html.push('<div style="margin-bottom:10px">');
      html.push('<h4 style="margin:0 0 4px 0">'+esc(name)+'</h4>');
      html.push('<p class="fine"><b>Type:</b> '+esc(type)+'</p>');
      if (raw){
        const pl = raw.getAttribute && (raw.getAttribute('partnerLink') || raw.getAttribute('partnerlink') || '');
        const op = raw.getAttribute && raw.getAttribute('operation');
        // Fetch normalized activity for variable names
        let actObj = null;
        if (state && state.model && state.model.activities){
          actObj = state.model.activities.find(a=>a.raw === raw) || null;
        }
        let inV  = '';
        let outV = '';
        // Prefer normalized inputVar/outputVar values if available
        if (actObj){ inV = actObj.inputVar || ''; outV = actObj.outputVar || ''; }
        // Fallback to raw attributes
        if (!inV)  inV  = raw.getAttribute && (raw.getAttribute('inputVariable') || raw.getAttribute('inputvariable') || raw.getAttribute('variable'));
        if (!outV) outV = raw.getAttribute && (raw.getAttribute('outputVariable') || raw.getAttribute('outputvariable'));
        if (pl || op) html.push('<p class="fine"><b>Service:</b> '+esc(`${pl}${pl && op ? ' ' : ''}${op}`.trim())+'</p>');
        if (inV || outV) html.push('<p class="fine"><b>Variables:</b> '+esc(`${inV || ''}${(inV && outV) ? '→' : ''}${outV || ''}`.trim())+'</p>');
        const attrs = [];
        if (raw.attributes){
          for (const attr of Array.from(raw.attributes)){
            const k = attr.name; const v = attr.value;
            if (!['name','label','id','partnerLink','partnerlink','operation','inputVariable','inputvariable','variable','outputVariable','outputvariable'].includes(k)){
              attrs.push(`${k}="${esc(v)}"`);
            }
          }
        }
        if (attrs.length) html.push('<p class="fine"><b>Attributes:</b> '+attrs.join(' ')+'</p>');
      }
      html.push('</div>');
    });
    detailsDiv.innerHTML = html.join('');
  }
</script>
</body>
</html>
